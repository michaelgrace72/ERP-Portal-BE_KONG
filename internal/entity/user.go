package entity

import (
	"fmt"

	"github.com/google/uuid"
	"gorm.io/gorm"
)

type Gender string

const (
	Male   Gender = "Male"
	Female Gender = "Female"
	Other  Gender = "Other"
)

func (g Gender) IsValid() bool {
	switch g {
	case Male, Female, Other:
		return true
	default:
		return false
	}
}

func (g Gender) String() string {
	return string(g)
}

type User struct {
	ID         int64  `gorm:"primaryKey;autoIncrement;column:id"`
	UUID       string `gorm:"type:uuid;uniqueIndex;not null"` // For Kong consumer - generated by BeforeCreate hook
	Code       string `gorm:"uniqueIndex;type:varchar(11);not null"`
	Name       string `gorm:"not null"`
	Email      string `gorm:"type:varchar(100);uniqueIndex;not null;column:email"`
	Password   string `gorm:"type:varchar(255);column:password"`
	Avatar     string `gorm:"default:''"`
	Gender     Gender `gorm:"type:gender;default:null"`
	IsActive   bool   `gorm:"default:true;not null"`
	IsVerified bool   `gorm:"default:false;not null"`

	OAuthProvider string `gorm:"type:varchar(50);column:oauth_provider"`
	OAuthID       string `gorm:"type:varchar(255);column:oauth_id"`

	Audit
}

func (User) TableName() string {
	return "users"
}

func NewUser(name, email, password, avatar string, Gender Gender) (*User, error) {
	return &User{
		Name:     name,
		Email:    email,
		Password: password,
		Avatar:   avatar,
		Gender:   Gender,
	}, nil
}

func NewUserFromOAuth(name, emailStr, oauthProvider, oauthID, avatar string) (*User, error) {
	return &User{
		Name:          name,
		Email:         emailStr,
		Password:      "",
		Avatar:        avatar,
		OAuthProvider: oauthProvider,
		OAuthID:       oauthID,
		IsVerified:    true,
		Gender:        Other,
		IsActive:      true,
	}, nil
}

func (u *User) Equals(other *User) bool {
	if other == nil {
		return false
	}

	return u.ID == other.ID &&
		u.Name == other.Name &&
		u.Email == other.Email
}

func (u *User) SetEmail(email string) {
	u.Email = email
}

func (u *User) SetPassword(hashedPassword string) {
	u.Password = hashedPassword
}

func (u *User) Activate() {
	u.IsActive = true
}

func (u *User) Deactivate() {
	u.IsActive = false
}

func (u *User) VerifyEmail() {
	u.IsVerified = true
}

func (u *User) IsOAuthUser() bool {
	return u.OAuthProvider != "" && u.OAuthID != ""
}

// BeforeCreate hook to generate UUID and Code before creating the user
func (u *User) BeforeCreate(tx *gorm.DB) error {
	// Generate UUID if not set
	if u.UUID == "" {
		u.UUID = uuid.New().String()
	}
	
	// Generate user code if not set
	if u.Code == "" {
		// Get the next ID from the sequence
		var nextID int64
		if err := tx.Raw("SELECT nextval('users_id_seq')").Scan(&nextID).Error; err != nil {
			return err
		}
		
		// Format: USR00000001 (USR + 8 digits = 11 characters total)
		u.Code = fmt.Sprintf("USR%08d", nextID)
	}
	
	return nil
}
